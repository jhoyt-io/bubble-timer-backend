# Cursor Rules for Bubble Timer Backend Project

## Deployment Safety Rule
- NEVER run deployment commands (cdk deploy, npm run deploy, etc.)
- NEVER execute commands that could modify production infrastructure
- If infrastructure changes are needed, only suggest them or create the files, but don't deploy
- Always ask for explicit permission before any deployment-related actions

## Incremental Development Rules
- ALWAYS follow the incremental development loop:
  1. Build and run tests to establish baseline before making changes
  2. Add a test that will fail until your new feature/change is complete (TDD approach)
  3. Make an incremental step toward the final solution
  4. Add relevant tests to cover what you've written
  5. Ensure all tests pass, including the initial acceptance tests
  6. Proceed with the next step toward the final solution
- NO big-bang changes: Every change should be small, testable, and verifiable
- Every step should be well-tested to guard against regressions
- If a change is large, break it into smaller, incremental steps that can be tested independently

## Git and Code Management Rules
- NEVER commit code directly to main branch
- Stage changes for human review instead of committing
- Work on feature branches when appropriate and ask for merge reviews
- Use git to view history and understand context, but don't commit without explicit permission
- The human-AI devloop: Stage changes → Human review → Human commits/pushes

## Testing Requirements
- ALWAYS run tests before and after any changes: `npm run build:test`
- Maintain or improve test coverage with every change
- Focus on comprehensive WebSocket testing - this is the top priority
- Test WebSocket message handling, DynamoDB interactions, and API Gateway responses
- Simulate real device interactions in tests
- Add integration tests for end-to-end flows
- Test error scenarios and edge cases

## Testing Pattern Requirements
- Use Given/When/Then pattern for all tests to tell a complete story
- Structure tests as: `describe("Given [context]", () => { describe("When [action]", () => { test("Then [expected outcome]", () => { ... }) }) })`
- Make test names descriptive and avoid "it should" patterns
- Ensure tests serve as documentation of expected behavior
- Write tests that can serve as a blueprint for implementation

## Code Quality Rules
- Provide clear explanations of issues and solutions
- Always build and test locally after making changes
- Fix any new errors introduced before proceeding
- Add tests to cover new functionality or existing functionality that might be impacted
- Document changes and reasoning in docs/ for significant changes
- Clean up any unused code introduced with each change

## Architecture Context Rules
- ALWAYS read `docs/ARCHITECTURE.md` first for data flows and component responsibilities
- Reference `docs/QUICK_REFERENCE.md` for debugging commands and common patterns
- Check `docs/FEATURE_EXTENSION_PATTERNS.md` for guidance on extending core systems
- Use the documentation to understand WebSocket, API Gateway, and DynamoDB patterns before making changes
- Key architecture points: Lambda handlers → DynamoDB operations, WebSocket connections, API Gateway responses

## Task Management System
- Use the `tasks/` directory for tracking major work and implementation plans
- Create implementation plans in `tasks/active/` when explicitly requested by the user
- Create summary files in `tasks/done/` for major changes that affect 50%+ of the codebase or fundamental architectural approaches
- Use `TASK_TEMPLATE.md` as a starting point for new tasks
- Do NOT create task files for every chat - only for significant work or when explicitly requested
- When completing major work, create a summary file in `tasks/done/` documenting the changes, decisions, and outcomes

## Documentation Requirements
- Keep `docs/` directory updated with current architecture and patterns
- Document any new patterns or architectural decisions
- Maintain `QUICK_REFERENCE.md` with common commands and debugging steps
- Update `ARCHITECTURE.md` when making significant architectural changes
- Document test patterns and strategies in `TESTING.md`

## Priority Focus Areas
1. **WebSocket Testing**: Comprehensive testing of WebSocket message handling, connection management, and real-time updates
2. **Integration Testing**: End-to-end testing of API → DynamoDB → WebSocket flows
3. **Error Handling**: Robust error handling and edge case testing
4. **Performance Testing**: Load testing and performance validation
5. **Security Testing**: Authentication, authorization, and data validation testing

## Test Writing Guidelines
- Write tests that tell a story about the system behavior
- Use descriptive context in "Given" blocks
- Make "When" blocks describe the specific action being tested
- Use "Then" blocks to describe the expected outcome
- Avoid repeating information between test description and expect statements
- Focus on behavior and outcomes rather than implementation details
- Make tests readable enough to serve as documentation
